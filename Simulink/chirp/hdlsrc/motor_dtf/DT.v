// -------------------------------------------------------------
// 
// File Name: hdlsrc\motor_dtf\DT.v
// Created: 2023-04-14 14:31:39
// 
// Generated by MATLAB 9.11 and HDL Coder 3.19
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1
// Target subsystem base rate: 1
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// PV                            ce_out        1
// MV                            ce_out        1
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: DT
// Source Path: motor_dtf/DT
// Hierarchy Level: 0
// 
// Simulink model description for motor_dtf:
// 
// Symmetric FIR Filter
// This example shows how to use HDL Coder(TM) to check, generate,
// and verify HDL for a fixed-point symmetric FIR filter. 
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module DT
          (clk,
           reset_x,
           clk_enable,
           SP,
           kp,
           ti,
           ce_out,
           PV,
           MV);


  input   clk;
  input   reset_x;
  input   clk_enable;
  input   signed [15:0] SP;  // sfix16_En10
  input   signed [15:0] kp;  // sfix16_En10
  input   signed [15:0] ti;  // sfix16_En10
  output  ce_out;
  output  signed [15:0] PV;  // sfix16_En10
  output  signed [15:0] MV;  // sfix16_En10


  wire enb;
  reg signed [15:0] s_state_out2;  // sfix16_En10
  wire signed [31:0] nume_gain2_mul_temp;  // sfix32_En20
  wire signed [15:0] s_nume_gain2;  // sfix16_En10
  reg signed [15:0] s_state_out1;  // sfix16_En10
  wire signed [31:0] nume_gain1_mul_temp;  // sfix32_En20
  wire signed [15:0] s_nume_gain1;  // sfix16_En10
  wire signed [31:0] denom_gain2_mul_temp;  // sfix32_En20
  wire signed [15:0] s_denom_gain2;  // sfix16_En10
  wire signed [15:0] s_denom_acc_out2;  // sfix16_En10
  wire signed [31:0] denom_gain1_mul_temp;  // sfix32_En20
  wire signed [15:0] s_denom_gain1;  // sfix16_En10
  wire signed [15:0] Add_out1;  // sfix16_En10
  wire signed [31:0] Product1_mul_temp;  // sfix32_En20
  wire signed [15:0] Product1_out1;  // sfix16_En10
  reg signed [15:0] Discrete_Time_Integrator1_x_reg;  // sfix16_En10
  wire signed [15:0] Discrete_Time_Integrator1_u_add;  // sfix16_En10
  wire signed [15:0] s_nume_acc_out2;  // sfix16_En10
  wire signed [31:0] Product_mul_temp;  // sfix32_En20
  wire signed [15:0] Product_out1;  // sfix16_En10
  wire signed [15:0] Add1_out1;  // sfix16_En10
  reg signed [15:0] Discrete_Time_Integrator_x_reg;  // sfix16_En10
  wire signed [15:0] Discrete_Time_Integrator_u_add;  // sfix16_En10
  wire signed [15:0] s_denom_acc_out1;  // sfix16_En10
  wire signed [31:0] nume_gain_b0_mul_temp;  // sfix32_En20
  wire signed [15:0] s_nume_gain_b0;  // sfix16_En10
  wire signed [15:0] s_nume_acc_out1;  // sfix16_En10


  assign enb = clk_enable;

  assign nume_gain2_mul_temp = 16'sb0000000000010010 * s_state_out2;
  assign s_nume_gain2 = nume_gain2_mul_temp[25:10];



  assign nume_gain1_mul_temp = 16'sb0000000000100100 * s_state_out1;
  assign s_nume_gain1 = nume_gain1_mul_temp[25:10];



  always @(posedge clk)
    begin : s_state_out2_1_process
      if (reset_x == 1'b1) begin
        s_state_out2 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          s_state_out2 <= s_state_out1;
        end
      end
    end



  assign denom_gain2_mul_temp = 16'sb0000000000111101 * s_state_out2;
  assign s_denom_gain2 = denom_gain2_mul_temp[25:10];



  always @(posedge clk)
    begin : s_state_out1_1_process
      if (reset_x == 1'b1) begin
        s_state_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          s_state_out1 <= s_denom_acc_out2;
        end
      end
    end



  assign denom_gain1_mul_temp = 16'sb1111100110111001 * s_state_out1;
  assign s_denom_gain1 = denom_gain1_mul_temp[25:10];



  assign Product1_mul_temp = Add_out1 * ti;
  assign Product1_out1 = Product1_mul_temp[25:10];


  assign Discrete_Time_Integrator1_u_add = Discrete_Time_Integrator1_x_reg + Product1_out1;



  always @(posedge clk)
    begin : Discrete_Time_Integrator1_reg_process
      if (reset_x == 1'b1) begin
        Discrete_Time_Integrator1_x_reg <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Discrete_Time_Integrator1_x_reg <= Discrete_Time_Integrator1_u_add;
        end
      end
    end


  assign Add_out1 = SP - s_nume_acc_out2;


  assign Product_mul_temp = Add_out1 * kp;
  assign Product_out1 = Product_mul_temp[25:10];


  assign Add1_out1 = Product_out1 + Discrete_Time_Integrator1_x_reg;


  assign Discrete_Time_Integrator_u_add = Discrete_Time_Integrator_x_reg + Add1_out1;



  always @(posedge clk)
    begin : Discrete_Time_Integrator_reg_process
      if (reset_x == 1'b1) begin
        Discrete_Time_Integrator_x_reg <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Discrete_Time_Integrator_x_reg <= Discrete_Time_Integrator_u_add;
        end
      end
    end


  assign s_denom_acc_out1 = Discrete_Time_Integrator_x_reg - s_denom_gain1;



  assign s_denom_acc_out2 = s_denom_acc_out1 - s_denom_gain2;



  assign nume_gain_b0_mul_temp = 16'sb0000000000010010 * s_denom_acc_out2;
  assign s_nume_gain_b0 = nume_gain_b0_mul_temp[25:10];



  assign s_nume_acc_out1 = s_nume_gain_b0 + s_nume_gain1;



  assign s_nume_acc_out2 = s_nume_acc_out1 + s_nume_gain2;


  assign PV = s_nume_acc_out2;

  assign MV = Add1_out1;

  assign ce_out = clk_enable;

endmodule  // DT

